// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

namespace TinyPG
{
    #region Scanner

    public partial class Scanner
    {
        public string Input;
        public int StartPos = 0;
        public int EndPos = 0;
        public int CurrentLine;
        public int CurrentColumn;
        public int CurrentPosition;
        public List<Token> Skipped; // tokens that were skipped
        public Dictionary<TokenType, Regex> Patterns;

        private Token LookAheadToken;
        private List<TokenType> Tokens;
        private List<TokenType> SkipList; // tokens to be skipped

        public Scanner()
        {
            Regex regex;
            Patterns = new Dictionary<TokenType, Regex>();
            Tokens = new List<TokenType>();
            LookAheadToken = null;
            Skipped = new List<Token>();

            SkipList = new List<TokenType>();
            SkipList.Add(TokenType.WHITESPACE);

            regex = new Regex(@"[0-9]+", RegexOptions.Compiled);
            Patterns.Add(TokenType.NUMBER, regex);
            Tokens.Add(TokenType.NUMBER);

            regex = new Regex(@"(\+|-)", RegexOptions.Compiled);
            Patterns.Add(TokenType.PLUSMINUS, regex);
            Tokens.Add(TokenType.PLUSMINUS);

            regex = new Regex(@"\*|/", RegexOptions.Compiled);
            Patterns.Add(TokenType.MULTDIV, regex);
            Tokens.Add(TokenType.MULTDIV);

            regex = new Regex(@"\(", RegexOptions.Compiled);
            Patterns.Add(TokenType.BROPEN, regex);
            Tokens.Add(TokenType.BROPEN);

            regex = new Regex(@"\)", RegexOptions.Compiled);
            Patterns.Add(TokenType.BRCLOSE, regex);
            Tokens.Add(TokenType.BRCLOSE);

            regex = new Regex(@"\=", RegexOptions.Compiled);
            Patterns.Add(TokenType.ASSIGNMENT, regex);
            Tokens.Add(TokenType.ASSIGNMENT);

            regex = new Regex(@"\&", RegexOptions.Compiled);
            Patterns.Add(TokenType.AND, regex);
            Tokens.Add(TokenType.AND);

            regex = new Regex(@"[*]", RegexOptions.Compiled);
            Patterns.Add(TokenType.STAR, regex);
            Tokens.Add(TokenType.STAR);

            regex = new Regex(@"[<]", RegexOptions.Compiled);
            Patterns.Add(TokenType.LESSTHAN, regex);
            Tokens.Add(TokenType.LESSTHAN);

            regex = new Regex(@"\|", RegexOptions.Compiled);
            Patterns.Add(TokenType.OR, regex);
            Tokens.Add(TokenType.OR);

            regex = new Regex(@"label?", RegexOptions.Compiled);
            Patterns.Add(TokenType.LABEL, regex);
            Tokens.Add(TokenType.LABEL);

            regex = new Regex(@"clear", RegexOptions.Compiled);
            Patterns.Add(TokenType.CLEAR, regex);
            Tokens.Add(TokenType.CLEAR);

            regex = new Regex(@"@?\""(?=(\""\""|[^\""])*\"")", RegexOptions.Compiled);
            Patterns.Add(TokenType.QUOTEBEGIN, regex);
            Tokens.Add(TokenType.QUOTEBEGIN);

            regex = new Regex(@"\""", RegexOptions.Compiled);
            Patterns.Add(TokenType.QUOTEEND, regex);
            Tokens.Add(TokenType.QUOTEEND);

            regex = new Regex(@"(?!NULL)(\""\""|[^\""])*", RegexOptions.Compiled);
            Patterns.Add(TokenType.QUOTED, regex);
            Tokens.Add(TokenType.QUOTED);

            regex = new Regex(@"if", RegexOptions.Compiled);
            Patterns.Add(TokenType.IF, regex);
            Tokens.Add(TokenType.IF);

            regex = new Regex(@"insheet", RegexOptions.Compiled);
            Patterns.Add(TokenType.INSHEET, regex);
            Tokens.Add(TokenType.INSHEET);

            regex = new Regex(@"length", RegexOptions.Compiled);
            Patterns.Add(TokenType.LENGTH, regex);
            Tokens.Add(TokenType.LENGTH);

            regex = new Regex(@"log", RegexOptions.Compiled);
            Patterns.Add(TokenType.LOG, regex);
            Tokens.Add(TokenType.LOG);

            regex = new Regex(@"(?:[\w]\:|\\)", RegexOptions.Compiled);
            Patterns.Add(TokenType.ROOTFILEPATH, regex);
            Tokens.Add(TokenType.ROOTFILEPATH);

            regex = new Regex(@"\==", RegexOptions.Compiled);
            Patterns.Add(TokenType.EQUALITY, regex);
            Tokens.Add(TokenType.EQUALITY);

            regex = new Regex(@"\!=", RegexOptions.Compiled);
            Patterns.Add(TokenType.NOTEQUAL, regex);
            Tokens.Add(TokenType.NOTEQUAL);

            regex = new Regex(@"\\n", RegexOptions.Compiled);
            Patterns.Add(TokenType.ENDLINE, regex);
            Tokens.Add(TokenType.ENDLINE);

            regex = new Regex(@"\\", RegexOptions.Compiled);
            Patterns.Add(TokenType.FORWARDSLASH, regex);
            Tokens.Add(TokenType.FORWARDSLASH);

            regex = new Regex(@"replace?", RegexOptions.Compiled);
            Patterns.Add(TokenType.REPLACE, regex);
            Tokens.Add(TokenType.REPLACE);

            regex = new Regex(@"variable", RegexOptions.Compiled);
            Patterns.Add(TokenType.VARIABLENAME, regex);
            Tokens.Add(TokenType.VARIABLENAME);

            regex = new Regex(@"gen?", RegexOptions.Compiled);
            Patterns.Add(TokenType.GEN, regex);
            Tokens.Add(TokenType.GEN);

            regex = new Regex(@",", RegexOptions.Compiled);
            Patterns.Add(TokenType.COMMA, regex);
            Tokens.Add(TokenType.COMMA);

            regex = new Regex(@"[.]", RegexOptions.Compiled);
            Patterns.Add(TokenType.DOT, regex);
            Tokens.Add(TokenType.DOT);

            regex = new Regex(@".csv", RegexOptions.Compiled);
            Patterns.Add(TokenType.CSVFORMART, regex);
            Tokens.Add(TokenType.CSVFORMART);

            regex = new Regex(@".xls", RegexOptions.Compiled);
            Patterns.Add(TokenType.XLSFORMART, regex);
            Tokens.Add(TokenType.XLSFORMART);

            regex = new Regex(@".xlsx", RegexOptions.Compiled);
            Patterns.Add(TokenType.XLSXFORMART, regex);
            Tokens.Add(TokenType.XLSXFORMART);

            regex = new Regex(@".smcl", RegexOptions.Compiled);
            Patterns.Add(TokenType.SMCLFORMART, regex);
            Tokens.Add(TokenType.SMCLFORMART);

            regex = new Regex(@"format", RegexOptions.Compiled);
            Patterns.Add(TokenType.FORMART, regex);
            Tokens.Add(TokenType.FORMART);

            regex = new Regex(@"date", RegexOptions.Compiled);
            Patterns.Add(TokenType.DATE, regex);
            Tokens.Add(TokenType.DATE);

            regex = new Regex(@"list", RegexOptions.Compiled);
            Patterns.Add(TokenType.LIST, regex);
            Tokens.Add(TokenType.LIST);

            regex = new Regex(@"sort", RegexOptions.Compiled);
            Patterns.Add(TokenType.SORT, regex);
            Tokens.Add(TokenType.SORT);

            regex = new Regex(@"NULL", RegexOptions.Compiled);
            Patterns.Add(TokenType.NULL, regex);
            Tokens.Add(TokenType.NULL);

            regex = new Regex(@"close", RegexOptions.Compiled);
            Patterns.Add(TokenType.CLOSE, regex);
            Tokens.Add(TokenType.CLOSE);

            regex = new Regex(@"repeat", RegexOptions.Compiled);
            Patterns.Add(TokenType.REPEAT, regex);
            Tokens.Add(TokenType.REPEAT);

            regex = new Regex(@"[[]", RegexOptions.Compiled);
            Patterns.Add(TokenType.ARRAYSTART, regex);
            Tokens.Add(TokenType.ARRAYSTART);

            regex = new Regex(@"[]]", RegexOptions.Compiled);
            Patterns.Add(TokenType.ARRAYEND, regex);
            Tokens.Add(TokenType.ARRAYEND);

            regex = new Regex(@"[tT][aA][bB]", RegexOptions.Compiled);
            Patterns.Add(TokenType.TAB, regex);
            Tokens.Add(TokenType.TAB);

            regex = new Regex(@"([%][t][d])", RegexOptions.Compiled);
            Patterns.Add(TokenType.FORMATS, regex);
            Tokens.Add(TokenType.FORMATS);

            regex = new Regex(@"\n", RegexOptions.Compiled);
            Patterns.Add(TokenType.NEWLINE, regex);
            Tokens.Add(TokenType.NEWLINE);

            regex = new Regex(@"(?!.)(?!tab)(?!label)(?!length)(?!if)([a-zA-Z][a-zA-Z0-9_]*)", RegexOptions.Compiled);
            Patterns.Add(TokenType.VARIABLE, regex);
            Tokens.Add(TokenType.VARIABLE);

            regex = new Regex(@"(?!tab)(?!label)(?!if)([a-zA-Z][a-zA-Z0-9_]*)", RegexOptions.Compiled);
            Patterns.Add(TokenType.OBJECT, regex);
            Tokens.Add(TokenType.OBJECT);

            regex = new Regex(@",m", RegexOptions.Compiled);
            Patterns.Add(TokenType.VARIABLE2, regex);
            Tokens.Add(TokenType.VARIABLE2);

            regex = new Regex(@"([a-zA-Z_][a-zA-Z0-9_]*)", RegexOptions.Compiled);
            Patterns.Add(TokenType.DIRECTORYNAME, regex);
            Tokens.Add(TokenType.DIRECTORYNAME);

            regex = new Regex(@"(?![*/])[^\n]*\n?", RegexOptions.Compiled);
            Patterns.Add(TokenType.TEXT, regex);
            Tokens.Add(TokenType.TEXT);

            regex = new Regex(@"^$", RegexOptions.Compiled);
            Patterns.Add(TokenType.EOF, regex);
            Tokens.Add(TokenType.EOF);

            regex = new Regex(@"$", RegexOptions.Compiled);
            Patterns.Add(TokenType.EMPTY, regex);
            Tokens.Add(TokenType.EMPTY);

            regex = new Regex(@"\r", RegexOptions.Compiled);
            Patterns.Add(TokenType.RETURN, regex);
            Tokens.Add(TokenType.RETURN);

            regex = new Regex(@"[/][*]", RegexOptions.Compiled);
            Patterns.Add(TokenType.STARTMULTILINECOMMENT, regex);
            Tokens.Add(TokenType.STARTMULTILINECOMMENT);

            regex = new Regex(@"[*][/]", RegexOptions.Compiled);
            Patterns.Add(TokenType.ENDMULTILINECOMMENT, regex);
            Tokens.Add(TokenType.ENDMULTILINECOMMENT);

            regex = new Regex(@"[/][/]", RegexOptions.Compiled);
            Patterns.Add(TokenType.SINGLELINECOMMENT, regex);
            Tokens.Add(TokenType.SINGLELINECOMMENT);

            regex = new Regex(@"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/", RegexOptions.Compiled);
            Patterns.Add(TokenType.COMMENTBLOCK, regex);
            Tokens.Add(TokenType.COMMENTBLOCK);

            regex = new Regex(";", RegexOptions.Compiled);
            Patterns.Add(TokenType.EOS, regex);
            Tokens.Add(TokenType.EOS);

            regex = new Regex(@"\s+", RegexOptions.Compiled);
            Patterns.Add(TokenType.WHITESPACE, regex);
            Tokens.Add(TokenType.WHITESPACE);


        }

        public void Init(string input)
        {
            this.Input = input;
            StartPos = 0;
            EndPos = 0;
            CurrentLine = 0;
            CurrentColumn = 0;
            CurrentPosition = 0;
            LookAheadToken = null;
        }

        public Token GetToken(TokenType type)
        {
            Token t = new Token(this.StartPos, this.EndPos);
            t.Type = type;
            return t;
        }

         /// <summary>
        /// executes a lookahead of the next token
        /// and will advance the scan on the input string
        /// </summary>
        /// <returns></returns>
        public Token Scan(params TokenType[] expectedtokens)
        {
            Token tok = LookAhead(expectedtokens); // temporarely retrieve the lookahead
            LookAheadToken = null; // reset lookahead token, so scanning will continue
            StartPos = tok.EndPos;
            EndPos = tok.EndPos; // set the tokenizer to the new scan position
            return tok;
        }

        /// <summary>
        /// returns token with longest best match
        /// </summary>
        /// <returns></returns>
        public Token LookAhead(params TokenType[] expectedtokens)
        {
            int i;
            int startpos = StartPos;
            Token tok = null;
            List<TokenType> scantokens;


            // this prevents double scanning and matching
            // increased performance
            if (LookAheadToken != null 
                && LookAheadToken.Type != TokenType._UNDETERMINED_ 
                && LookAheadToken.Type != TokenType._NONE_) return LookAheadToken;

            // if no scantokens specified, then scan for all of them (= backward compatible)
            if (expectedtokens.Length == 0)
                scantokens = Tokens;
            else
            {
                scantokens = new List<TokenType>(expectedtokens);
                scantokens.AddRange(SkipList);
            }

            do
            {

                int len = -1;
                TokenType index = (TokenType)int.MaxValue;
                string input = Input.Substring(startpos);

                tok = new Token(startpos, EndPos);

                for (i = 0; i < scantokens.Count; i++)
                {
                    Regex r = Patterns[scantokens[i]];
                    Match m = r.Match(input);
                    if (m.Success && m.Index == 0 && ((m.Length > len) || (scantokens[i] < index && m.Length == len )))
                    {
                        len = m.Length;
                        index = scantokens[i];  
                    }
                }

                if (index >= 0 && len >= 0)
                {
                    tok.EndPos = startpos + len;
                    tok.Text = Input.Substring(tok.StartPos, len);
                    tok.Type = index;
                }
                else if (tok.StartPos < tok.EndPos - 1)
                {
                    tok.Text = Input.Substring(tok.StartPos, 1);
                }

                if (SkipList.Contains(tok.Type))
                {
                    startpos = tok.EndPos;
                    Skipped.Add(tok);
                }
                else
                {
                    // only assign to non-skipped tokens
                    tok.Skipped = Skipped; // assign prior skips to this token
                    Skipped = new List<Token>(); //reset skips
                }
            }
            while (SkipList.Contains(tok.Type));

            LookAheadToken = tok;
            return tok;
        }
    }

    #endregion

    #region Token

    public enum TokenType
    {

            //Non terminal tokens:
            _NONE_  = 0,
            _UNDETERMINED_= 1,

            //Non terminal tokens:
            Start   = 2,
            CodeBlock= 3,
            CommandLine= 4,
            String  = 5,
            CommandExpr= 6,
            RepeatExpr= 7,
            JoinCondition= 8,
            EqualitySymbol= 9,
            ValueExpres= 10,
            ConditionComparer= 11,
            ConditionBracketed= 12,
            CondExpr= 13,

            //Terminal tokens:
            NUMBER  = 14,
            PLUSMINUS= 15,
            MULTDIV = 16,
            BROPEN  = 17,
            BRCLOSE = 18,
            ASSIGNMENT= 19,
            AND     = 20,
            STAR    = 21,
            LESSTHAN= 22,
            OR      = 23,
            LABEL   = 24,
            CLEAR   = 25,
            QUOTEBEGIN= 26,
            QUOTEEND= 27,
            QUOTED  = 28,
            IF      = 29,
            INSHEET = 30,
            LENGTH  = 31,
            LOG     = 32,
            ROOTFILEPATH= 33,
            EQUALITY= 34,
            NOTEQUAL= 35,
            ENDLINE = 36,
            FORWARDSLASH= 37,
            REPLACE = 38,
            VARIABLENAME= 39,
            GEN     = 40,
            COMMA   = 41,
            DOT     = 42,
            CSVFORMART= 43,
            XLSFORMART= 44,
            XLSXFORMART= 45,
            SMCLFORMART= 46,
            FORMART = 47,
            DATE    = 48,
            LIST    = 49,
            SORT    = 50,
            NULL    = 51,
            CLOSE   = 52,
            REPEAT  = 53,
            ARRAYSTART= 54,
            ARRAYEND= 55,
            TAB     = 56,
            FORMATS = 57,
            NEWLINE = 58,
            VARIABLE= 59,
            OBJECT  = 60,
            VARIABLE2= 61,
            DIRECTORYNAME= 62,
            TEXT    = 63,
            EOF     = 64,
            EMPTY   = 65,
            RETURN  = 66,
            STARTMULTILINECOMMENT= 67,
            ENDMULTILINECOMMENT= 68,
            SINGLELINECOMMENT= 69,
            COMMENTBLOCK= 70,
            EOS     = 71,
            WHITESPACE= 72
    }

    public class Token
    {
        private int startpos;
        private int endpos;
        private string text;
        private object value;

        // contains all prior skipped symbols
        private List<Token> skipped;

        public int StartPos { 
            get { return startpos;} 
            set { startpos = value; }
        }

        public int Length { 
            get { return endpos - startpos;} 
        }

        public int EndPos { 
            get { return endpos;} 
            set { endpos = value; }
        }

        public string Text { 
            get { return text;} 
            set { text = value; }
        }

        public List<Token> Skipped { 
            get { return skipped;} 
            set { skipped = value; }
        }
        public object Value { 
            get { return value;} 
            set { this.value = value; }
        }

        [XmlAttribute]
        public TokenType Type;

        public Token()
            : this(0, 0)
        {
        }

        public Token(int start, int end)
        {
            Type = TokenType._UNDETERMINED_;
            startpos = start;
            endpos = end;
            Text = ""; // must initialize with empty string, may cause null reference exceptions otherwise
            Value = null;
        }

        public void UpdateRange(Token token)
        {
            if (token.StartPos < startpos) startpos = token.StartPos;
            if (token.EndPos > endpos) endpos = token.EndPos;
        }

        public override string ToString()
        {
            if (Text != null)
                return Type.ToString() + " '" + Text + "'";
            else
                return Type.ToString();
        }
    }

    #endregion
}
