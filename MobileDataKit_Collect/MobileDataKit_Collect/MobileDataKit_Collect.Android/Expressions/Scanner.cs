// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

namespace TinyPG
{
    #region Scanner

    public partial class Scanner
    {
        public string Input;
        public int StartPos = 0;
        public int EndPos = 0;
        public int CurrentLine;
        public int CurrentColumn;
        public int CurrentPosition;
        public List<Token> Skipped; // tokens that were skipped
        public Dictionary<TokenType, Regex> Patterns;

        private Token LookAheadToken;
        private List<TokenType> Tokens;
        private List<TokenType> SkipList; // tokens to be skipped

        public Scanner()
        {
            Regex regex;
            Patterns = new Dictionary<TokenType, Regex>();
            Tokens = new List<TokenType>();
            LookAheadToken = null;
            Skipped = new List<Token>();

            SkipList = new List<TokenType>();
            SkipList.Add(TokenType.WHITESPACE);

            regex = new Regex(@"[0-9]+", RegexOptions.Compiled);
            Patterns.Add(TokenType.NUMBER, regex);
            Tokens.Add(TokenType.NUMBER);

            regex = new Regex(@"(\+|-)", RegexOptions.Compiled);
            Patterns.Add(TokenType.PLUSMINUS, regex);
            Tokens.Add(TokenType.PLUSMINUS);

            regex = new Regex(@"\*|/", RegexOptions.Compiled);
            Patterns.Add(TokenType.MULTDIV, regex);
            Tokens.Add(TokenType.MULTDIV);

            regex = new Regex(@"\(", RegexOptions.Compiled);
            Patterns.Add(TokenType.BROPEN, regex);
            Tokens.Add(TokenType.BROPEN);

            regex = new Regex(@"\)", RegexOptions.Compiled);
            Patterns.Add(TokenType.BRCLOSE, regex);
            Tokens.Add(TokenType.BRCLOSE);

            regex = new Regex(@"\=", RegexOptions.Compiled);
            Patterns.Add(TokenType.ASSIGNMENT, regex);
            Tokens.Add(TokenType.ASSIGNMENT);

            regex = new Regex(@"\&", RegexOptions.Compiled);
            Patterns.Add(TokenType.AND, regex);
            Tokens.Add(TokenType.AND);

            regex = new Regex(@"[*]", RegexOptions.Compiled);
            Patterns.Add(TokenType.STAR, regex);
            Tokens.Add(TokenType.STAR);

            regex = new Regex(@"[<]", RegexOptions.Compiled);
            Patterns.Add(TokenType.LESSTHAN, regex);
            Tokens.Add(TokenType.LESSTHAN);

            regex = new Regex(@"[>]", RegexOptions.Compiled);
            Patterns.Add(TokenType.GREATERTHAN, regex);
            Tokens.Add(TokenType.GREATERTHAN);

            regex = new Regex(@"\|", RegexOptions.Compiled);
            Patterns.Add(TokenType.OR, regex);
            Tokens.Add(TokenType.OR);

            regex = new Regex(@"label?", RegexOptions.Compiled);
            Patterns.Add(TokenType.LABEL, regex);
            Tokens.Add(TokenType.LABEL);

            regex = new Regex(@"clear", RegexOptions.Compiled);
            Patterns.Add(TokenType.CLEAR, regex);
            Tokens.Add(TokenType.CLEAR);

            regex = new Regex(@"@?\""(?=(\""\""|[^\""])*\"")", RegexOptions.Compiled);
            Patterns.Add(TokenType.QUOTEBEGIN, regex);
            Tokens.Add(TokenType.QUOTEBEGIN);

            regex = new Regex(@"\""", RegexOptions.Compiled);
            Patterns.Add(TokenType.QUOTEEND, regex);
            Tokens.Add(TokenType.QUOTEEND);

            regex = new Regex(@"(?!NULL)(\""\""|[^\""])*", RegexOptions.Compiled);
            Patterns.Add(TokenType.QUOTED, regex);
            Tokens.Add(TokenType.QUOTED);

            regex = new Regex(@"if", RegexOptions.Compiled);
            Patterns.Add(TokenType.IF, regex);
            Tokens.Add(TokenType.IF);

            regex = new Regex(@"while", RegexOptions.Compiled);
            Patterns.Add(TokenType.WHILE, regex);
            Tokens.Add(TokenType.WHILE);

            regex = new Regex(@"count", RegexOptions.Compiled);
            Patterns.Add(TokenType.COUNT, regex);
            Tokens.Add(TokenType.COUNT);

            regex = new Regex(@"insheet", RegexOptions.Compiled);
            Patterns.Add(TokenType.INSHEET, regex);
            Tokens.Add(TokenType.INSHEET);

            regex = new Regex(@"length", RegexOptions.Compiled);
            Patterns.Add(TokenType.LENGTH, regex);
            Tokens.Add(TokenType.LENGTH);

            regex = new Regex(@"log", RegexOptions.Compiled);
            Patterns.Add(TokenType.LOG, regex);
            Tokens.Add(TokenType.LOG);

            regex = new Regex(@"(?:[\w]\:|\\)", RegexOptions.Compiled);
            Patterns.Add(TokenType.ROOTFILEPATH, regex);
            Tokens.Add(TokenType.ROOTFILEPATH);

            regex = new Regex(@"\==", RegexOptions.Compiled);
            Patterns.Add(TokenType.EQUALITY, regex);
            Tokens.Add(TokenType.EQUALITY);

            regex = new Regex(@"\!=", RegexOptions.Compiled);
            Patterns.Add(TokenType.NOTEQUAL, regex);
            Tokens.Add(TokenType.NOTEQUAL);

            regex = new Regex(@"\\n", RegexOptions.Compiled);
            Patterns.Add(TokenType.ENDLINE, regex);
            Tokens.Add(TokenType.ENDLINE);

            regex = new Regex(@"\\", RegexOptions.Compiled);
            Patterns.Add(TokenType.FORWARDSLASH, regex);
            Tokens.Add(TokenType.FORWARDSLASH);

            regex = new Regex(@"replace?", RegexOptions.Compiled);
            Patterns.Add(TokenType.REPLACE, regex);
            Tokens.Add(TokenType.REPLACE);

            regex = new Regex(@"variable", RegexOptions.Compiled);
            Patterns.Add(TokenType.VARIABLENAME, regex);
            Tokens.Add(TokenType.VARIABLENAME);

            regex = new Regex(@"gen?", RegexOptions.Compiled);
            Patterns.Add(TokenType.GEN, regex);
            Tokens.Add(TokenType.GEN);

            regex = new Regex(@",", RegexOptions.Compiled);
            Patterns.Add(TokenType.COMMA, regex);
            Tokens.Add(TokenType.COMMA);

            regex = new Regex(@"[.]", RegexOptions.Compiled);
            Patterns.Add(TokenType.DOT, regex);
            Tokens.Add(TokenType.DOT);

            regex = new Regex(@".csv", RegexOptions.Compiled);
            Patterns.Add(TokenType.CSVFORMART, regex);
            Tokens.Add(TokenType.CSVFORMART);

            regex = new Regex(@".xls", RegexOptions.Compiled);
            Patterns.Add(TokenType.XLSFORMART, regex);
            Tokens.Add(TokenType.XLSFORMART);

            regex = new Regex(@".xlsx", RegexOptions.Compiled);
            Patterns.Add(TokenType.XLSXFORMART, regex);
            Tokens.Add(TokenType.XLSXFORMART);

            regex = new Regex(@".smcl", RegexOptions.Compiled);
            Patterns.Add(TokenType.SMCLFORMART, regex);
            Tokens.Add(TokenType.SMCLFORMART);

            regex = new Regex(@"format", RegexOptions.Compiled);
            Patterns.Add(TokenType.FORMART, regex);
            Tokens.Add(TokenType.FORMART);

            regex = new Regex(@"date", RegexOptions.Compiled);
            Patterns.Add(TokenType.DATE, regex);
            Tokens.Add(TokenType.DATE);

            regex = new Regex(@"list", RegexOptions.Compiled);
            Patterns.Add(TokenType.LIST, regex);
            Tokens.Add(TokenType.LIST);

            regex = new Regex(@"sort", RegexOptions.Compiled);
            Patterns.Add(TokenType.SORT, regex);
            Tokens.Add(TokenType.SORT);

            regex = new Regex(@"NULL", RegexOptions.Compiled);
            Patterns.Add(TokenType.NULL, regex);
            Tokens.Add(TokenType.NULL);

            regex = new Regex(@"close", RegexOptions.Compiled);
            Patterns.Add(TokenType.CLOSE, regex);
            Tokens.Add(TokenType.CLOSE);

            regex = new Regex(@"repeat", RegexOptions.Compiled);
            Patterns.Add(TokenType.REPEAT, regex);
            Tokens.Add(TokenType.REPEAT);

            regex = new Regex(@"foreach", RegexOptions.Compiled);
            Patterns.Add(TokenType.FOREACH, regex);
            Tokens.Add(TokenType.FOREACH);

            regex = new Regex(@"in", RegexOptions.Compiled);
            Patterns.Add(TokenType.IN, regex);
            Tokens.Add(TokenType.IN);

            regex = new Regex(@"[[]", RegexOptions.Compiled);
            Patterns.Add(TokenType.ARRAYSTART, regex);
            Tokens.Add(TokenType.ARRAYSTART);

            regex = new Regex(@"[]]", RegexOptions.Compiled);
            Patterns.Add(TokenType.ARRAYEND, regex);
            Tokens.Add(TokenType.ARRAYEND);

            regex = new Regex(@"[tT][aA][bB]", RegexOptions.Compiled);
            Patterns.Add(TokenType.TAB, regex);
            Tokens.Add(TokenType.TAB);

            regex = new Regex(@"([%][t][d])", RegexOptions.Compiled);
            Patterns.Add(TokenType.FORMATS, regex);
            Tokens.Add(TokenType.FORMATS);

            regex = new Regex(@"\n", RegexOptions.Compiled);
            Patterns.Add(TokenType.NEWLINE, regex);
            Tokens.Add(TokenType.NEWLINE);

            regex = new Regex(@"(?!while)(?!.)(?!tab)(?!label)(?!length)(?!if)([a-zA-Z][a-zA-Z0-9_]*)", RegexOptions.Compiled);
            Patterns.Add(TokenType.VARIABLE, regex);
            Tokens.Add(TokenType.VARIABLE);

            regex = new Regex(@"(?!foreach)(?!in)(?!while)(?!tab)(?!label)(?!if)([a-zA-Z][a-zA-Z0-9_]*)", RegexOptions.Compiled);
            Patterns.Add(TokenType.OBJECT, regex);
            Tokens.Add(TokenType.OBJECT);

            regex = new Regex(@",m", RegexOptions.Compiled);
            Patterns.Add(TokenType.VARIABLE2, regex);
            Tokens.Add(TokenType.VARIABLE2);

            regex = new Regex(@"([a-zA-Z_][a-zA-Z0-9_]*)", RegexOptions.Compiled);
            Patterns.Add(TokenType.DIRECTORYNAME, regex);
            Tokens.Add(TokenType.DIRECTORYNAME);

            regex = new Regex(@"(?![*/])[^\n]*\n?", RegexOptions.Compiled);
            Patterns.Add(TokenType.TEXT, regex);
            Tokens.Add(TokenType.TEXT);

            regex = new Regex(@"^$", RegexOptions.Compiled);
            Patterns.Add(TokenType.EOF, regex);
            Tokens.Add(TokenType.EOF);

            regex = new Regex(@"$", RegexOptions.Compiled);
            Patterns.Add(TokenType.EMPTY, regex);
            Tokens.Add(TokenType.EMPTY);

            regex = new Regex(@"\r", RegexOptions.Compiled);
            Patterns.Add(TokenType.RETURN, regex);
            Tokens.Add(TokenType.RETURN);

            regex = new Regex(@"[/][*]", RegexOptions.Compiled);
            Patterns.Add(TokenType.STARTMULTILINECOMMENT, regex);
            Tokens.Add(TokenType.STARTMULTILINECOMMENT);

            regex = new Regex(@"[*][/]", RegexOptions.Compiled);
            Patterns.Add(TokenType.ENDMULTILINECOMMENT, regex);
            Tokens.Add(TokenType.ENDMULTILINECOMMENT);

            regex = new Regex(@"[/][/]", RegexOptions.Compiled);
            Patterns.Add(TokenType.SINGLELINECOMMENT, regex);
            Tokens.Add(TokenType.SINGLELINECOMMENT);

            regex = new Regex(@"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/", RegexOptions.Compiled);
            Patterns.Add(TokenType.COMMENTBLOCK, regex);
            Tokens.Add(TokenType.COMMENTBLOCK);

            regex = new Regex(";", RegexOptions.Compiled);
            Patterns.Add(TokenType.EOS, regex);
            Tokens.Add(TokenType.EOS);

            regex = new Regex(@"\s+", RegexOptions.Compiled);
            Patterns.Add(TokenType.WHITESPACE, regex);
            Tokens.Add(TokenType.WHITESPACE);


        }

        public void Init(string input)
        {
            this.Input = input;
            StartPos = 0;
            EndPos = 0;
            CurrentLine = 0;
            CurrentColumn = 0;
            CurrentPosition = 0;
            LookAheadToken = null;
        }

        public Token GetToken(TokenType type)
        {
            Token t = new Token(this.StartPos, this.EndPos);
            t.Type = type;
            return t;
        }

         /// <summary>
        /// executes a lookahead of the next token
        /// and will advance the scan on the input string
        /// </summary>
        /// <returns></returns>
        public Token Scan(params TokenType[] expectedtokens)
        {
            Token tok = LookAhead(expectedtokens); // temporarely retrieve the lookahead
            LookAheadToken = null; // reset lookahead token, so scanning will continue
            StartPos = tok.EndPos;
            EndPos = tok.EndPos; // set the tokenizer to the new scan position
            return tok;
        }

        /// <summary>
        /// returns token with longest best match
        /// </summary>
        /// <returns></returns>
        public Token LookAhead(params TokenType[] expectedtokens)
        {
            int i;
            int startpos = StartPos;
            Token tok = null;
            List<TokenType> scantokens;


            // this prevents double scanning and matching
            // increased performance
            if (LookAheadToken != null 
                && LookAheadToken.Type != TokenType._UNDETERMINED_ 
                && LookAheadToken.Type != TokenType._NONE_) return LookAheadToken;

            // if no scantokens specified, then scan for all of them (= backward compatible)
            if (expectedtokens.Length == 0)
                scantokens = Tokens;
            else
            {
                scantokens = new List<TokenType>(expectedtokens);
                scantokens.AddRange(SkipList);
            }

            do
            {

                int len = -1;
                TokenType index = (TokenType)int.MaxValue;
                string input = Input.Substring(startpos);

                tok = new Token(startpos, EndPos);

                for (i = 0; i < scantokens.Count; i++)
                {
                    Regex r = Patterns[scantokens[i]];
                    Match m = r.Match(input);
                    if (m.Success && m.Index == 0 && ((m.Length > len) || (scantokens[i] < index && m.Length == len )))
                    {
                        len = m.Length;
                        index = scantokens[i];  
                    }
                }

                if (index >= 0 && len >= 0)
                {
                    tok.EndPos = startpos + len;
                    tok.Text = Input.Substring(tok.StartPos, len);
                    tok.Type = index;
                }
                else if (tok.StartPos < tok.EndPos - 1)
                {
                    tok.Text = Input.Substring(tok.StartPos, 1);
                }

                if (SkipList.Contains(tok.Type))
                {
                    startpos = tok.EndPos;
                    Skipped.Add(tok);
                }
                else
                {
                    // only assign to non-skipped tokens
                    tok.Skipped = Skipped; // assign prior skips to this token
                    Skipped = new List<Token>(); //reset skips
                }
            }
            while (SkipList.Contains(tok.Type));

            LookAheadToken = tok;
            return tok;
        }
    }

    #endregion

    #region Token

    public enum TokenType
    {

            //Non terminal tokens:
            _NONE_  = 0,
            _UNDETERMINED_= 1,

            //Non terminal tokens:
            Start   = 2,
            CodeBlock= 3,
            CommandLine= 4,
            String  = 5,
            CommandExpr= 6,
            RepeatExpr= 7,
            ForeachExpr= 8,
            ArrayExpr= 9,
            JoinCondition= 10,
            EqualitySymbol= 11,
            ValueExpres= 12,
            ConditionComparer= 13,
            ConditionBracketed= 14,
            ConditionClause= 15,
            CondExpr= 16,

            //Terminal tokens:
            NUMBER  = 17,
            PLUSMINUS= 18,
            MULTDIV = 19,
            BROPEN  = 20,
            BRCLOSE = 21,
            ASSIGNMENT= 22,
            AND     = 23,
            STAR    = 24,
            LESSTHAN= 25,
            GREATERTHAN= 26,
            OR      = 27,
            LABEL   = 28,
            CLEAR   = 29,
            QUOTEBEGIN= 30,
            QUOTEEND= 31,
            QUOTED  = 32,
            IF      = 33,
            WHILE   = 34,
            COUNT   = 35,
            INSHEET = 36,
            LENGTH  = 37,
            LOG     = 38,
            ROOTFILEPATH= 39,
            EQUALITY= 40,
            NOTEQUAL= 41,
            ENDLINE = 42,
            FORWARDSLASH= 43,
            REPLACE = 44,
            VARIABLENAME= 45,
            GEN     = 46,
            COMMA   = 47,
            DOT     = 48,
            CSVFORMART= 49,
            XLSFORMART= 50,
            XLSXFORMART= 51,
            SMCLFORMART= 52,
            FORMART = 53,
            DATE    = 54,
            LIST    = 55,
            SORT    = 56,
            NULL    = 57,
            CLOSE   = 58,
            REPEAT  = 59,
            FOREACH = 60,
            IN      = 61,
            ARRAYSTART= 62,
            ARRAYEND= 63,
            TAB     = 64,
            FORMATS = 65,
            NEWLINE = 66,
            VARIABLE= 67,
            OBJECT  = 68,
            VARIABLE2= 69,
            DIRECTORYNAME= 70,
            TEXT    = 71,
            EOF     = 72,
            EMPTY   = 73,
            RETURN  = 74,
            STARTMULTILINECOMMENT= 75,
            ENDMULTILINECOMMENT= 76,
            SINGLELINECOMMENT= 77,
            COMMENTBLOCK= 78,
            EOS     = 79,
            WHITESPACE= 80
    }

    public class Token
    {
        private int startpos;
        private int endpos;
        private string text;
        private object value;

        // contains all prior skipped symbols
        private List<Token> skipped;

        public int StartPos { 
            get { return startpos;} 
            set { startpos = value; }
        }

        public int Length { 
            get { return endpos - startpos;} 
        }

        public int EndPos { 
            get { return endpos;} 
            set { endpos = value; }
        }

        public string Text { 
            get { return text;} 
            set { text = value; }
        }

        public List<Token> Skipped { 
            get { return skipped;} 
            set { skipped = value; }
        }
        public object Value { 
            get { return value;} 
            set { this.value = value; }
        }

        [XmlAttribute]
        public TokenType Type;

        public Token()
            : this(0, 0)
        {
        }

        public Token(int start, int end)
        {
            Type = TokenType._UNDETERMINED_;
            startpos = start;
            endpos = end;
            Text = ""; // must initialize with empty string, may cause null reference exceptions otherwise
            Value = null;
        }

        public void UpdateRange(Token token)
        {
            if (token.StartPos < startpos) startpos = token.StartPos;
            if (token.EndPos > endpos) endpos = token.EndPos;
        }

        public override string ToString()
        {
            if (Text != null)
                return Type.ToString() + " '" + Text + "'";
            else
                return Type.ToString();
        }
    }

    #endregion
}
